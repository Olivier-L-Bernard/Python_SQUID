# -*- coding: utf-8 -*-
"""
Auteur: Olivier Bernard
Créée mercredi le 22 mai 2019  à (11:45) 
Entrer: Clavier
Sortie: Moniteur

Code permettant une tentative de déterminer l'évolution de la valeur absolue de 
l'aimantation selon l'angle de rotation (référence avec l'axe Easy = 0deg). Le code
requiert d'avoir le fichier de l'axe hard ainsi que celui de l'axe easy pour pouvoir
en extraire les données ainsi que de calculer la valeur de M pour un angle donné.

Les fichiers sont ceux du SQUID sans l'en tëte (on conserve le titre des colonnes).
"""
import numpy as np
from matplotlib import pyplot as plt
import math
import os.path

#----------------------------------------------------------------------------
from _Fonctions_v2 import getColumns

#Calculs du delta s et ecriture des fichier txt-------------------------------
def traceAng_MvsAngs(masse,Hch, tch, N1, N2, cryst, save_path, ech, date):   
    
    t_a= {0:'(Easy)' , 1:'(Hard)'}
    t_c = {0:'Tk', 1:'Th', 2:'LM', 3:'LMh', 4:'FOe', 5:'Fh'}
    Tsaut = 2

    nom_doc= str(N1) +'.txt'
    file = open(os.path.join(save_path + str(cryst) +'/'+ str(ech) + '/' + str(date), nom_doc), 'r')
    cols, indexToName = getColumns(file)
    file.close()
    print('La colonne temps de', str(N1) ,'est d.une longueur de:', len(cols['Time'])) 

    t_c[0] = list(np.float_(cols['Temperature (K)']))
    t_c[2] = list(np.float_(cols['Long Moment (emu)'])/masse) #Division par masse pour avoir M
    t_c[4] = list(np.float_(cols['Field (Oe)'])/10000) #Division par 10k pour avoir H en Tesla

    nom_doch= str(N2) +'.txt'
    file = open(os.path.join(save_path + str(cryst) +'/'+ str(ech) + '/' + str(date), nom_doch), 'r')
    cols, indexToName = getColumns(file) #Il vous faut voir le fichier de fonction
    file.close()
    print('La colonne temps de', str(N2) ,'est d.une longueur de:', len(cols['Time'])) 

    t_c[1] = list(np.float_(cols['Temperature (K)']))
    t_c[3] = list(np.float_(cols['Long Moment (emu)'])/masse) #Division par masse pour avoir M
    t_c[5] = list(np.float_(cols['Field (Oe)'])/10000) #Division par 10k pour avoir H en Tesla

    #------------------------------------------------------------------------
    nbval = 2 #Nombre de fichiers
    i = 0 #Fichier initiale
    e = len(t_c)+4 #Indique le nombre de liste/variables
    x = [[] for i in range(e)] #pour les valeurs dans les .txt
                            #ang,M,ME,Mh,H,HE,Hh,T,Truff
    y= [[] for i in range(2)] #pour pst liste #pstL1, pstL2
    while i < nbval:
        tmax = max(t_c[0+i][:]) #Va chercher le T max
        print('La température maximale de l.axe', t_a[i],' est de' , tmax , 'K')
        champ = [] #Liste qui tien un registre des champs mag
        saute = [] #Liste qui tien un registre du nombre de mesure pour un T donnee
        Tb = round(min(t_c[0+i][:]), 1) #Indique la température minimale du fichier
        n=0
        pstlist = 0 #indique ou dans la liste le code est rendu (position d'une valeur)
        while Tb < (tmax - Tsaut):
            saut = 0 #Nombre de mesure pour la température 1 (disons il y a 15 mesures pour T=2K)
            saut2 = 0 #Nombre de mesure pour la température suivante (disons il y a 16 mesures pour T=2.1K)
            while t_c[4+i][pstlist + saut] < 7: #Utilise le champ mag comme référence. D'hab 7T est max et atteint
                saut += 1
            while t_c[4+i][pstlist + saut + saut2 + 1 ] < 7: #Utilise le champ mag comme référence. D'hab 7T est max et atteint
                saut2 += 1
            T1 = sum(t_c[0+i][pstlist:pstlist + saut ])/len(t_c[0+i][pstlist:pstlist+saut]) #Determine la temperature moyenne de la prise de mesure
            T2 = sum(t_c[0+i][pstlist + saut + 1 :pstlist + saut + saut2])/len(t_c[0+i][pstlist + saut+1:pstlist + saut + saut2]) #Determine la temperature moyenne de la prise de mesure suivante
            dT = T2 - T1 #Determine le saut en température
            c= i
            champ.append(c) #prise en note du champ mag 
            saute.append(saut) #prise en note du nombre de mesures
            x[7+i].append(round(Tb,1)) #arrondi de la mesure
            y[i].append(pstlist) #prise en note de la position dans le fichier
            n+=1
            pstlist += saut+1
            Tb += dT #changement de la temperature
        i+= 1
    print('Position des groupes de mesures:',y)
    print('Températures:',x[7], x[8])
    
    mn=0 #Suivi de la donnees calculees
    theta = 0 #angle depart
    while theta < 361: #verification pour un tour <<complet>>
         Hang = [abs(Hch*np.cos(math.radians(theta))), abs(Hch*np.sin(math.radians(theta)))] #Angles selon easy et hard
         m = [x[7].index(tch), x[8].index(tch)] #Cherche la valeur de température dans la liste
         k=0
         while k < len(Hang):
             z = y[k][m[k]] #Donne la position dans les listes des températures (et autres)
             o = min(t_c[4+k][z:y[k][m[k]+1]], key=lambda x: abs(x - Hang[k])) #determine le champ mag le plus pres de celui etudie
             p = t_c[4+k][z:y[k][m[k]+1]].index(o) #determine la position du champ le plus pres
             if o > Hang[k]: #Si le champ o est plus grand que le champ etudie
                 q = t_c[2+k][z + p] - t_c[2+k][z+ p -1]#difference de M
                 r = t_c[4+k][z + p] - t_c[4+k][z + p -1] # difference de H
                 s = q/r #Evolution de M vs H
                 u = t_c[4+k][z + p] - Hang[k] #Max de H bracket - H[e ou h]
                 v=(r-u)*s #qte var
                 w = t_c[2+k][z + p -1] +v #Magnetisation finale (min bracket + var)
             if o <= Hang[k]: #Si le champ o est plus petit que le champ etudie
                 q = t_c[2+k][z + p+1] - t_c[2+k][z + p] #difference de M
                 r = t_c[4+k][z + p+1] - t_c[4+k][z + p]  # difference de H
                 s = q/r #Evolution de M vs H
                 u = t_c[4+k][z + p+1] - Hang[k] #Max de H bracket - H[e ouh]
                 v=(r-u)*s #qte var
                 w = t_c[2+k][z + p] +v #Magnetisation finale (min bracket + var)
             x[2+k].append(w) #Mise en note de ME ou Mh
             k+=1 #Passage a l'etude de l'autre axe/fichier
         Mtot = math.sqrt(x[2][mn]*x[2][mn] + x[3][mn]*x[3][mn]) #Grandeur de l'aimantation
         x[0].append(theta) #Mise en note de l'angle
         x[1].append(Mtot) #Mise en note de M total
         theta +=5 #increment de l'angle
         mn +=1

#Graphique --------------------------------------------------------------------
    plt.plot(x[0],x[1], '-.', linewidth = 1, label = 'M total')
    plt.plot(x[0],x[2], '-', linewidth = 1, label = 'M Easy')
    plt.plot(x[0],x[3], '--', linewidth = 1, label = 'M Hard')
    plt.xlabel(r'Angle $\theta$') # axe x angle
    plt.ylabel(r'M (Am$^2$ /kg)') #axe y aimantation
    plt.title(r'Variation de M en fonction de $\theta$ du'+ cryst + ' a '+str(Hch)+'T et '+str(tch)+'K')
    plt.legend( loc='best',  frameon = True)
    plt.show()
  
 #Lire les commentaires de la premiere partie #############################################################################  
def traceAng_MvsAngp(masse,Hch, N1, N2, cryst , save_path, ech, fpath, date):  

    t_a= {0:'(Easy)' , 1:'(Hard)'}
    t_c = {0:'Tk', 1:'Th', 2:'LM', 3:'LMh', 4:'FOe', 5:'Fh'}
    Tsaut = 2

    #Axe = t_a[0] #Important de le spécifier aussi
    nom_doc= str(N1) +'.txt'
    file = open(os.path.join(save_path + str(cryst) +'/' + str(date), nom_doc), 'r')
    cols, indexToName = getColumns(file)
    file.close()
    print('La colonne temps de', str(N1) ,'est d.une longueur de:', len(cols['Time'])) 

    t_c[0] = list(np.float_(cols['Temperature (K)']))
    t_c[2] = list(np.float_(cols['Long Moment (emu)'])/masse) #Division par masse pour avoir M
    t_c[4] = list(np.float_(cols['Field (Oe)'])/10000) #Division par 10k pour avoir H en Tesla

    nom_doch= str(N2) +'.txt'
    file = open(os.path.join(save_path + str(cryst) +'/' + str(date), nom_doch), 'r')
    cols, indexToName = getColumns(file)
    file.close()
    print('La colonne temps de', str(N2) ,'est d.une longueur de:', len(cols['Time'])) 

    t_c[1] = list(np.float_(cols['Temperature (K)']))
    t_c[3] = list(np.float_(cols['Long Moment (emu)'])/masse) #Division par masse pour avoir M
    t_c[5] = list(np.float_(cols['Field (Oe)'])/10000) #Division par 10k pour avoir H en Teslaç
    
    #-------------------------------------------------------------------------
    nbval = 2 #Nombre de fichiers
    i = 0 #Fichier initiale
    e = len(t_c)+4 #Indique le nombre de liste/variables
    x = [[] for i in range(e)] #pour les valeurs dans les .txt
    x10 = [0]                       #ang,M,ME,Mh,H,HE,Hh,T,Truff, T , ch
    y= [[] for i in range(2)] #pour pst liste #pstL1, pstL2
    while i < nbval:
        tmax = max(t_c[0+i][:])
        print('La température maximale de l.axe', t_a[i],' est de' , tmax , 'K')
        champ = []
        saute = []
        Tb = round(min(t_c[0+i][:]), 1) #Indique la température minimale du fichier
        n=0
        pstlist = 0 #indique ou dans la liste le code est rendu (position d'une valeur)
        while Tb < (tmax - Tsaut):
            saut = 0 #Nombre de mesure pour la température 1
            saut2 = 0 #Nombre de mesure pour la température suivante
            while t_c[4+i][pstlist + saut] < 7: #Utilise le champ mag comme référence. D'hab 7T est max et atteint
                x10.append(t_c[4+i][pstlist + saut+1])
                saut += 1
            while t_c[4+i][pstlist + saut + saut2 + 1 ] < 7: #Utilise le champ mag comme référence. D'hab 7T est max et atteint
                saut2 += 1
            T1 = sum(t_c[0+i][pstlist:pstlist + saut ])/len(t_c[0+i][pstlist:pstlist+saut]) #Determine la temperature moyenne de la prise de mesure
            T2 = sum(t_c[0+i][pstlist + saut + 1 :pstlist + saut + saut2])/len(t_c[0+i][pstlist + saut+1:pstlist + saut + saut2])
            dT = T2 - T1 #Determine le saut en température
            c= i
            champ.append(c)
            saute.append(saut)
            x[7+i].append(round(Tb,1)) #Apend les températures 
            y[i].append(pstlist) #Append les positions dans les listes
            n+=1
            pstlist += saut+1
            Tb += dT
        i+= 1       
    
    fd=open(os.path.join(fpath +str(cryst)+'/'+ str(ech) + '/' +str(date), cryst + '_crystal_MCE_MvsA_'+ 'champ' + str(Hch) +'.txt'), "w")
    fd.write('Time'+','+'Comment'+','+'Angle (deg)'+','+'Temperature (K)'+','+'Long Moment (emu)'+','+'Easy moment (emu)'+','+'Hard moment (emu)'+','+'Long Offset Std Dev'+','+'Long Algorithm'+','+'Long Reg Fit'+','+'Long Reg Factor'+','+'Trans Moment (emu)'+','+'Trans Scan Std Dev'+','+'Trans Offset (cm)'+','+'Trans Offset Std Dev'+','+'Trans Algorithm'+','+'Trans Reg Fit'+','+'Trans Reg Factor'+','+'Long Moment [w/o ABS] (emu)'+','+'Long Scan Std Dev [w/o ABS]'+','+'Long Offset [w/o ABS] (cm)'+','+'Long Offset Std Dev [w/o ABS]'+','+'Long Reg Fit [w/o ABS]'+','+'Trans Moment [w/o ABS] (emu)'+','+'Trans Scan Std Dev [w/o ABS]'+','+'Trans Offset [w/o ABS] (cm)'+','+'Trans Offset Std Dev [w/o ABS]'+','+'Trans Reg Fit [w/o ABS]'+','+'RSO Position (deg)'+','+'Amplitude (cm)'+','+'Frequency'+','+'Cycles to Average'+','+'Scans per Measurement'+','+'Delta Temp (K)'+','+'Error'+','+'EC Comp. Running'+','+'Using ABS'+','+"\n")
    mn=0 #Suivi de la donnees calculees
    for temp in (x[8][:len(x[8])-1]):
        tch = temp #temperature choisie en K
        m = [x[7].index(tch), x[8].index(tch)] #Cherche la valeur de température dans la liste
        theta = 0 #angle depart
        while theta < 361: #verification pour un tour <<complet>>
            Hang = [abs(Hch*np.cos(math.radians(theta))), abs(Hch*np.sin(math.radians(theta)))] #Angles selon easy et hard
            m = [x[7].index(tch), x[8].index(tch)] #Cherche la valeur de température dans la liste
            k=0
            while k < len(Hang):
                    z = y[k][m[k]] #Donne la position dans les listes des températures (et autres)
                    o = min(t_c[4+k][z:y[k][m[k]+1]], key=lambda x: abs(x - Hang[k])) #determine le champ mag le plus pres de celui etudie
                    p = t_c[4+k][z:y[k][m[k]+1]].index(o) #determine la position du champ le plus pres
                    if o > Hang[k]: #Si le champ o est plus grand que le champ etudie
                        q = t_c[2+k][z + p] - t_c[2+k][z+ p -1]#difference de M
                        r = t_c[4+k][z + p] - t_c[4+k][z + p -1] # difference de H
                        s = q/r #Evolution de M vs H
                        u = t_c[4+k][z + p] - Hang[k] #Max de H bracket - H[e ou h]
                        v=(r-u)*s #qte var
                        w = t_c[2+k][z + p -1] +v #Magnetisation finale (min bracket + var)
                    if o <= Hang[k]: #Si le champ o est plus petit que le champ etudie
                        q = t_c[2+k][z + p+1] - t_c[2+k][z + p] #difference de M
                        r = t_c[4+k][z + p+1] - t_c[4+k][z + p]  # difference de H
                        s = q/r #Evolution de M vs H
                        u = t_c[4+k][z + p+1] - Hang[k] #Max de H bracket - H[e ouh]
                        v=(r-u)*s #qte var
                        w = t_c[2+k][z + p] +v #Magnetisation finale (min bracket + var)
                    x[2+k].append(w) #Mise en note de ME ou Mh
                    k+=1 #Passage a l'etude de l'autre axe/fichier
            Mtot = math.sqrt(x[2][mn]*x[2][mn] + x[3][mn]*x[3][mn]) #Grandeur de l'aimantation
            x[0].append(theta) #Mise en note de l'angle
            x[1].append(Mtot) #Mise en note de M total
            x[9].append(tch)
            mn +=1
            theta+=5
            
    plt.plot(x[0],x[2], '-', linewidth = 1, label = 'M Easy ' + str(Hch)+'T')
    plt.plot(x[0],x[3], '--', linewidth = 1, label = 'M Hard ' + str(Hch)+'T')
    plt.plot(x[0],x[1], '-.', linewidth = 1, label = 'M total ' + str(Hch)+'T')
    plt.xlabel(r'Angle $\theta$') # axe x angle
    plt.ylabel(r'M (Am$^2$ /kg)') #axe y aimantation
    plt.title(r'Variation de M en fonction de $\theta$ du '+cryst+' a '+str(Hch)+'T et '+str(tch)+'K')
    plt.legend( loc='best',  frameon = True)
    plt.show()
    
    kk=0
    while kk < len(x[1]):
        fd.write('1.0'+ ','+','+str(x[0][kk])+','+ str(x[9][kk]) + ',' + str(x[1][kk]*masse) +','+ str(x[2][kk]*masse)+ ','+ str(x[3][kk]*masse)+','+','+','+','+','+','+','+','+','+','+','+','+','+','+','+','+','+','+','+','+','+','+','+','+','+','+','+','+','+','+','+"\n")
        kk +=1
    fd.close()   
